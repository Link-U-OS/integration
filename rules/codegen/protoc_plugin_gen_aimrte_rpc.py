#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) 2025, AgiBot Inc.
# All rights reserved.

import sys

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.compiler.plugin_pb2 import CodeGeneratorRequest as CodeGeneratorRequest
from google.protobuf.compiler.plugin_pb2 import CodeGeneratorResponse as CodeGeneratorResponse
from google.protobuf.descriptor_pb2 import FileDescriptorProto


class AimRTeCodeGenerator(object):
    t_hfile_one_service_res_member: str = r"""
  ::aimrte::ctx::Server<{{rpc_req_name}}, {{rpc_rsp_name}}> {{rpc_func_name}};
"""

    t_hfile_one_service_proxy_res_member: str = r"""
  ::aimrte::ctx::Client<{{rpc_req_name}}, {{rpc_rsp_name}}> {{rpc_func_name}};
"""

    t_hfile_one_service_res_class: str = r"""
namespace res {
/**
 * @brief 一些实现细节
 */
namespace details {
using {{service_name}}Type      = {{service_name}}CoService;
using {{service_name}}ProxyType = {{service_name}}CoProxy;
}

/**
 * @brief 由 AimRTe 生成的 rpc 服务端资源标识符集合，每个资源描述符对应一个 rpc method.
 */
class {{service_name}} {
 public:
  /**
   * @brief Initialize the service resource based on AimRTe Context.
   */
  void Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string service_name = "");

 public:
  {{hfile_service_res_members}}

 public:
  /**
   * @return 本服务所有方法向 AimRT 注册时，使用的名称
   */
  static std::vector<std::string> GetMethodNames(std::string service_name = {});

  static constexpr bool IS_PROXY = false;

 private:
  std::shared_ptr<details::{{service_name}}Type> impl_;

 public:
  typedef struct {} ReflectionType;

  {{service_name}}() = default;
  {{service_name}}(const ReflectionType &) {}
  ReflectionType reflection() const { return {}; }
};

/**
 * @brief 由 AimRTe 生成的 rpc 客户端资源标识符集合，每个资源描述符对应一个 rpc method.
 */
class {{service_name}}Proxy {
 public:
  /**
   * @brief Initialize the service resource based on AimRTe Context.
   */
  void Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string service_name = "");

 public:
  {{hfile_service_proxy_res_members}}

 public:
  /**
   * @return 本服务所有方法向 AimRT 注册时，使用的名称
   */
  static std::vector<std::string> GetMethodNames(std::string service_name = {});

  static constexpr bool IS_PROXY = true;

 public:
  typedef struct {} ReflectionType;

  {{service_name}}Proxy() = default;
  {{service_name}}Proxy(const ReflectionType &) {}
  ReflectionType reflection() const { return {}; }
};
}"""

    t_hfile: str = r"""/**
 * @file {{file_name}}.h
 * @brief This file was generated by protoc-gen-aimrte_rpc which is a self-defined pb compiler plugin, do not edit it!!!
 */
#pragma once

#include "src/ctx/ctx.h"
#include "{{file_name}}.aimrt_rpc.pb.h"

#ifndef AIMRTE_RPC_CONTEXT_KEY_RETRY_TIMES
#define AIMRTE_RPC_CONTEXT_KEY_RETRY_TIMES  "aimrte-retry_times"
#endif

{{namespace_begin}}
{{hfile_service_res_class}}
{{namespace_end}}
"""

    t_ccfile_one_impl_func: str = r"""
  ::aimrt::co::Task<::aimrt::rpc::Status> {{rpc_func_name}}(
      aimrt::rpc::ContextRef ctx_ref,
      const {{rpc_req_name}}& req,
      {{rpc_rsp_name}}& rsp
  ) final {
    auto ctx_ptr = weak_ctx_ptr_.lock();
    if (ctx_ptr == nullptr)
      co_return ::aimrt::rpc::Status(::aimrt_rpc_status_code_t::AIMRT_RPC_STATUS_SVR_NOT_FOUND);

    co_return co_await ctx_ptr->srv().Serving(res_->{{rpc_func_name}}, ctx_ref, req, rsp);
  }"""

    t_ccfile_one_res_member: str = r"""
  this->{{rpc_func_name}} = ctx_ptr->srv().Init<{{rpc_req_name}}, {{rpc_rsp_name}}>(
    "pb:/" + service_name + "/{{rpc_func_name}}"
  );
"""

    t_ccfile_one_proxy_res_member: str = r"""
  this->{{rpc_func_name}} = ctx_ptr->cli().Init<{{rpc_req_name}}, {{rpc_rsp_name}}>(
    "pb:/" + service_name + "/{{rpc_func_name}}",
    [proxy](aimrt::rpc::ContextRef ctx_ref, const {{rpc_req_name}}& req, {{rpc_rsp_name}}& rsp)
      -> ::aimrt::co::Task<::aimrt::rpc::Status>
    {
      int retry_times = 1;
      auto retry_times_ctx = ctx_ref.GetMetaValue(AIMRTE_RPC_CONTEXT_KEY_RETRY_TIMES);
      AIMRTE_DEBUG("{{service_name}}.{{rpc_func_name}} retry times in ctx: {}", retry_times_ctx);
      if (!retry_times_ctx.empty()) {
        try {
          retry_times = std::stoi(std::string(retry_times_ctx));
        } catch (const std::exception& e) {
          AIMRTE_WARN("{{service_name}}.{{rpc_func_name}} invalid retry times: {}", retry_times_ctx);
        }
      }
      AIMRTE_DEBUG("{{service_name}}.{{rpc_func_name}} retry times: {}", retry_times);

      aimrt::rpc::Status status;
      for (int ii = 0; ii < retry_times; ++ii) {
        AIMRTE_DEBUG("{{service_name}}.{{rpc_func_name}} try for times #{}", ii);
        aimrt::rpc::Context ctx{ctx_ref};
        status = co_await proxy->{{rpc_func_name}}(ctx, req, rsp);
        if (status.OK()) co_return status;
      }
      AIMRTE_ERROR("RPC call {{service_name}}.{{rpc_func_name}} failed: {}", aimrt::rpc::Status::GetCodeMsg(status.Code()));
      co_return status;
    }
  );
"""

    t_ccfile_one_method_name: str = r"""
    "pb:/" + service_name + "/{{rpc_func_name}}",
"""

    t_ccfile_one_service_res_class: str = r"""
class {{service_name}}AimRTeImpl final: public {{service_name}}CoService {
 public:
  explicit {{service_name}}AimRTeImpl(
    std::weak_ptr<::aimrte::core::Context> weak_ctx_ptr, res::{{service_name}} * res)
    : weak_ctx_ptr_(std::move(weak_ctx_ptr)), res_(res) {
  }

 public:
  {{ccfile_service_impl_func}}

 private:
  // aimrte::ctx 上下文
  std::weak_ptr<::aimrte::core::Context> weak_ctx_ptr_;

  // 资源描述符
  res::{{service_name}} * res_ = nullptr;
};

namespace res {
void {{service_name}}::Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string service_name) {
  // 创建基于 aimrte::ctx 的服务实现
  impl_ = std::make_shared<{{service_name}}AimRTeImpl>(ctx_ptr->weak_from_this(), this);

  if (not service_name.empty())
    impl_->SetServiceName(service_name);
  else
    service_name = "{{package_name}}.{{service_name}}";

  // 初始化所有服务资源
  {{ccfile_service_res_members}}

  // 将本服务实现注册到 AimRT core 中
  ::aimrte::core::Context::GetRawRef(*ctx_ptr).GetRpcHandle().RegisterService(impl_.get());
}

std::vector<std::string> {{service_name}}::GetMethodNames(std::string service_name) {
  if (service_name.empty())
    service_name = "{{package_name}}.{{service_name}}";

  return {
    {{ccfile_method_names}}
  };
}

void {{service_name}}Proxy::Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string service_name) {
  // 取出 AimRT 的 rpc 管理器
  const ::aimrt::rpc::RpcHandleRef rpc_handle = ::aimrte::core::Context::GetRawRef(*ctx_ptr).GetRpcHandle();

  // 注册本 rpc proxy 类型
  if (not service_name.empty())
    ::aimrt::rpc::RegisterClientFunc<details::{{service_name}}ProxyType>(rpc_handle, service_name);
  else {
    ::aimrt::rpc::RegisterClientFunc<details::{{service_name}}ProxyType>(rpc_handle);
    service_name = "{{package_name}}.{{service_name}}";
  }

  // 创建本 rpc proxy 对象
  auto proxy = std::make_shared<details::{{service_name}}ProxyType>(rpc_handle);
  proxy->SetServiceName(service_name);

  // 初始化所有的服务资源
  {{ccfile_service_proxy_res_members}}
}

std::vector<std::string> {{service_name}}Proxy::GetMethodNames(std::string service_name) {
  if (service_name.empty())
    service_name = "{{package_name}}.{{service_name}}";

  return {
    {{ccfile_method_names}}
  };
}

} // namespace res
"""

    t_ccfile: str = r"""/**
 * @file {{file_name}}.cc
 * @brief This file was generated by protoc-gen-aimrte_rpc which is a self-defined pb compiler plugin, do not edit it!!!
 */

#include "{{file_name}}.h"

{{namespace_begin}}
{{ccfile_service_res_class}}
{{namespace_end}}
"""

    @staticmethod
    def gen_name_space_str(ns: str) -> str:
        return ns.replace(".", "::")

    @staticmethod
    def gen_namespace_begin_str(ns: str) -> str:
        namespace_vec: list[str] = ns.split(".")
        result: str = ""
        for itr in namespace_vec:
            result += "namespace " + itr + " {\n"
        return result

    @staticmethod
    def gen_namespace_end_str(ns: str) -> str:
        namespace_vec: list[str] = ns.split(".")
        result: str = ""
        for itr in namespace_vec:
            result += "}  // namespace " + itr + "\n"
        return result

    def generate(self, request: CodeGeneratorRequest) -> CodeGeneratorResponse:
        """Generate code for the given request"""
        response: CodeGeneratorResponse = CodeGeneratorResponse()
        response.supported_features = 1
        for proto_file in request.proto_file:
            if proto_file.name not in request.file_to_generate:
                continue

            # Generate code for each file
            file_name: str = proto_file.name
            package_name: str = proto_file.package
            namespace_begin: str = self.gen_namespace_begin_str(package_name)
            namespace_end: str = self.gen_namespace_end_str(package_name)
            cc_file_name: str = file_name.replace('.proto', '.cc')
            h_file_name: str = file_name.replace('.proto', '.h')

            hfile_service_res_class: str = ""
            ccfile_service_res_class: str = ""

            for ii in range(0, len(proto_file.service)):
                service: ServiceDescriptorProto = proto_file.service[ii]
                if ii != 0:
                    hfile_service_res_class += "\n"
                    ccfile_service_res_class += "\n"

                service_name: str = service.name

                hfile_service_res_members: str = ""
                hfile_service_proxy_res_members: str = ""

                ccfile_service_impl_func: str = ""
                ccfile_service_res_members: str = ""
                ccfile_service_proxy_res_members: str = ""
                ccfile_method_names: str = ""

                for jj in range(0, len(service.method)):
                    method: MethodDescriptorProto = service.method[jj]

                    rpc_func_name = method.name
                    rpc_req_name = self.gen_name_space_str(method.input_type)
                    rpc_rsp_name = self.gen_name_space_str(method.output_type)

                    hfile_one_service_res_member: str = self.t_hfile_one_service_res_member \
                        .replace("{{rpc_req_name}}", rpc_req_name) \
                        .replace("{{rpc_rsp_name}}", rpc_rsp_name) \
                        .replace("{{rpc_func_name}}", rpc_func_name)
                    hfile_service_res_members += hfile_one_service_res_member

                    hfile_one_service_proxy_res_member: str = self.t_hfile_one_service_proxy_res_member \
                        .replace("{{rpc_req_name}}", rpc_req_name) \
                        .replace("{{rpc_rsp_name}}", rpc_rsp_name) \
                        .replace("{{rpc_func_name}}", rpc_func_name)
                    hfile_service_proxy_res_members += hfile_one_service_proxy_res_member

                    ccfile_one_impl_func: str = self.t_ccfile_one_impl_func \
                        .replace("{{rpc_req_name}}", rpc_req_name) \
                        .replace("{{rpc_rsp_name}}", rpc_rsp_name) \
                        .replace("{{rpc_func_name}}", rpc_func_name)
                    ccfile_service_impl_func += ccfile_one_impl_func

                    ccfile_one_res_member: str = self.t_ccfile_one_res_member \
                        .replace("{{rpc_req_name}}", rpc_req_name) \
                        .replace("{{rpc_rsp_name}}", rpc_rsp_name) \
                        .replace("{{rpc_func_name}}", rpc_func_name)
                    ccfile_service_res_members += ccfile_one_res_member

                    ccfile_one_proxy_res_member: str = self.t_ccfile_one_proxy_res_member \
                        .replace("{{rpc_req_name}}", rpc_req_name) \
                        .replace("{{rpc_rsp_name}}", rpc_rsp_name) \
                        .replace("{{rpc_func_name}}", rpc_func_name)
                    ccfile_service_proxy_res_members += ccfile_one_proxy_res_member

                    ccfile_one_method_name: str = self.t_ccfile_one_method_name \
                        .replace("{{rpc_func_name}}", rpc_func_name)
                    ccfile_method_names += ccfile_one_method_name

                hfile_one_service_res_class: str = self.t_hfile_one_service_res_class \
                    .replace("{{hfile_service_res_members}}", hfile_service_res_members) \
                    .replace("{{hfile_service_proxy_res_members}}", hfile_service_proxy_res_members) \
                    .replace("{{service_name}}", service_name)
                hfile_service_res_class += hfile_one_service_res_class

                ccfile_one_service_res_class: str = self.t_ccfile_one_service_res_class \
                    .replace("{{ccfile_service_impl_func}}", ccfile_service_impl_func) \
                    .replace("{{ccfile_service_res_members}}", ccfile_service_res_members) \
                    .replace("{{ccfile_service_proxy_res_members}}", ccfile_service_proxy_res_members) \
                    .replace("{{ccfile_method_names}}", ccfile_method_names) \
                    .replace("{{service_name}}", service_name)
                ccfile_service_res_class += ccfile_one_service_res_class

            # hfile
            hfile: CodeGeneratorResponse.File = CodeGeneratorResponse.File()
            hfile.name = h_file_name
            hfile.content = self.t_hfile \
                .replace("{{hfile_service_res_class}}", hfile_service_res_class) \
                .replace("{{file_name}}", file_name.replace('.proto', '')) \
                .replace("{{namespace_begin}}", namespace_begin) \
                .replace("{{namespace_end}}", namespace_end) \
                .replace("{{package_name}}", package_name)
            response.file.append(hfile)

            # ccfile
            ccfile: CodeGeneratorResponse.File = CodeGeneratorResponse.File()
            ccfile.name = cc_file_name
            ccfile.content = self.t_ccfile \
                .replace("{{ccfile_service_res_class}}", ccfile_service_res_class) \
                .replace("{{file_name}}", file_name.replace('.proto', '')) \
                .replace("{{namespace_begin}}", namespace_begin) \
                .replace("{{namespace_end}}", namespace_end) \
                .replace("{{package_name}}", package_name)
            response.file.append(ccfile)

        response.supported_features |= CodeGeneratorResponse.FEATURE_PROTO3_OPTIONAL
        
        return response


if __name__ == '__main__':
    # Load the request from stdin
    request: CodeGeneratorRequest = CodeGeneratorRequest.FromString(sys.stdin.buffer.read())

    aimrte_code_generator: AimRTeCodeGenerator = AimRTeCodeGenerator()

    response: CodeGeneratorResponse = aimrte_code_generator.generate(request)

    # Serialize response and write to stdout
    sys.stdout.buffer.write(response.SerializeToString())
