#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) 2025, AgiBot Inc.
# All rights reserved.

import sys
import os
import re


def get_snake_case_name(text):
    # 用正则插入下划线：两个模式
    # 1. 小写字母后跟大写字母：eB → e_B
    # 2. 大写字母后跟大写+小写：XMLParser → XML_Parser

    s1 = re.sub(r'([a-z0-9])([A-Z])', r'\1_\2', text)
    s2 = re.sub(r'([A-Z]+)([A-Z][a-z])', r'\1_\2', s1)
    return s2.lower()


def gen_h_file(package_name, service_name):
    t_h_file = '''/**
 * @file {{service_name}}.h
 * @brief This file was generated by AimRTe ros2 protocol tool, do not edit it!!!
 */
#pragma once

#include "src/ctx/ctx.h"
#include "./{{service_name}}.aimrt_rpc.srv.h"


namespace {{package_name}} {
namespace srv {
namespace res {
/**
 * @brief 一些实现细节
 */
namespace details {
using {{service_name}}Type      = {{service_name}}CoService;
using {{service_name}}ProxyType = {{service_name}}CoProxy;
}

/**
 * @brief 由 AimRTe 生成的本 ros srv rpc 服务端的资源标识
 */
class {{service_name}} {
 public:
  /**
   * @brief Initialize the service resource based on AimRTe Context.
   */
  void Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string_view service_name = "");

 public:
  /**
   * @brief 本 ros srv 提供的函数调用的 rpc 资源标识
   */
  ::aimrte::ctx::Server<{{service_name}}_Request, {{service_name}}_Response> Func;

 public:
  /**
   * @return 本服务所有方法向 AimRT 注册时，使用的名称
   */
  static std::vector<std::string> GetMethodNames(std::string service_name = {});

  static constexpr bool IS_PROXY = false;

 private:
  std::shared_ptr<{{service_name}}CoService> impl_;

 public:
  typedef struct {} ReflectionType;

  {{service_name}}() = default;
  {{service_name}}(const ReflectionType &) {}
  ReflectionType reflection() const { return {}; }
};

/**
 * @brief 由 AimRTe 生成的本 ros srv rpc 客户端的资源标识
 */
class {{service_name}}Proxy {
 public:
  /**
   * @brief Initialize the service resource based on AimRTe Context.
   */
  void Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string_view service_name = "");

 public:
  /**
   * @brief 本 ros srv 提供的函数调用的 rpc 资源标识
   */
  ::aimrte::ctx::Client<{{service_name}}_Request, {{service_name}}_Response> Func;

 public:
  /**
   * @return 本服务所有方法向 AimRT 注册时，使用的名称
   */
  static std::vector<std::string> GetMethodNames(std::string service_name = {});

  static constexpr bool IS_PROXY = true;

 public:
  typedef struct {} ReflectionType;

  {{service_name}}Proxy() = default;
  {{service_name}}Proxy(const ReflectionType &) {}
  ReflectionType reflection() const { return {}; }
};

}  // namespace res
}  // namespace srv
}  // namespace {{package_name}}
'''

    h_file = str = t_h_file \
        .replace("{{service_name}}", service_name) \
        .replace("{{snake_case_service_name}}", get_snake_case_name(service_name)) \
        .replace("{{package_name}}", package_name)

    return h_file


def gen_cc_file(package_name, service_name):
    t_cc_file = '''/**
 * @file {{service_name}}.cc
 * @brief This file was generated by AimRTe ros2 protocol tool, do not edit it!!!
 */

#include "./{{service_name}}.h"

#ifndef AIMRTE_RPC_CONTEXT_KEY_RETRY_TIMES
#define AIMRTE_RPC_CONTEXT_KEY_RETRY_TIMES  "aimrte-retry_times"
#endif

namespace {{package_name}} {
namespace srv {

class {{service_name}}AimRTeImpl final: public {{service_name}}CoService {
 public:
  explicit {{service_name}}AimRTeImpl(
    std::weak_ptr<::aimrte::core::Context> weak_ctx_ptr, res::{{service_name}} * res)
      : weak_ctx_ptr_(std::move(weak_ctx_ptr)), res_(res) {
  }

 public:
  aimrt::co::Task<aimrt::rpc::Status> {{service_name}}(
    aimrt::rpc::ContextRef ctx_ref,
    const {{service_name}}_Request& req,
    {{service_name}}_Response& rsp
  ) final {
    auto ctx_ptr = weak_ctx_ptr_.lock();
    if (ctx_ptr == nullptr)
      co_return ::aimrt::rpc::Status(::aimrt_rpc_status_code_t::AIMRT_RPC_STATUS_SVR_NOT_FOUND);

    co_return co_await ctx_ptr->srv().Serving(res_->Func, ctx_ref, req, rsp);
  }

 private:
  // aimrte::ctx 上下文
  std::weak_ptr<::aimrte::core::Context> weak_ctx_ptr_;

  // 资源描述符
  res::{{service_name}} * res_ = nullptr;
};

namespace res {
void {{service_name}}::Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string_view service_name) {
  // 创建基于 aimrte::ctx 的服务实现
  impl_ = std::make_shared<{{service_name}}AimRTeImpl>(ctx_ptr->weak_from_this(), this);

  if (not service_name.empty())
    impl_->SetServiceName(service_name);

  // 初始化所有服务资源
  this->Func = ctx_ptr->srv().Init<{{service_name}}_Request, {{service_name}}_Response>(
    "ros2:/{{package_name}}/srv/{{service_name}}"
  );

  // 将本服务实现注册到 AimRT core 中
  ::aimrte::core::Context::GetRawRef(*ctx_ptr).GetRpcHandle().RegisterService(impl_.get());
}

std::vector<std::string> {{service_name}}::GetMethodNames(std::string service_name) {
  return {
    "ros2:/{{package_name}}/srv/{{service_name}}",
  };
}

void {{service_name}}Proxy::Init(const std::shared_ptr<::aimrte::core::Context> & ctx_ptr, std::string_view service_name) {
  // 取出 AimRT 的 rpc 管理器
  const ::aimrt::rpc::RpcHandleRef rpc_handle = ::aimrte::core::Context::GetRawRef(*ctx_ptr).GetRpcHandle();

  // 注册本 rpc proxy 类型
  if (not service_name.empty())
    ::aimrt::rpc::RegisterClientFunc<details::{{service_name}}ProxyType>(rpc_handle, service_name);
  else
    ::aimrt::rpc::RegisterClientFunc<details::{{service_name}}ProxyType>(rpc_handle);

  // 创建本 rpc proxy 对象
  auto proxy = std::make_shared<details::{{service_name}}ProxyType>(rpc_handle);

  if (not service_name.empty())
    proxy->SetServiceName(service_name);

  // 初始化所有的服务资源
  this->Func = ctx_ptr->cli().Init<{{service_name}}_Request, {{service_name}}_Response>(
    "ros2:/{{package_name}}/srv/{{service_name}}",
    [proxy](::aimrt::rpc::ContextRef ctx_ref, const {{service_name}}_Request& req, {{service_name}}_Response& rsp)
      -> ::aimrt::co::Task<::aimrt::rpc::Status>
    {
      int retry_times = 1;
      auto retry_times_ctx = ctx_ref.GetMetaValue(AIMRTE_RPC_CONTEXT_KEY_RETRY_TIMES);
      AIMRTE_DEBUG("{{service_name}}.{{rpc_func_name}} retry times in ctx: {}", retry_times_ctx);
      if (!retry_times_ctx.empty()) {
        try {
          retry_times = std::stoi(std::string(retry_times_ctx));
        } catch (const std::exception& e) {
          AIMRTE_WARN("{{service_name}}.{{rpc_func_name}} invalid retry times: {}", retry_times_ctx);
        }
      }
      AIMRTE_DEBUG("{{service_name}}.{{rpc_func_name}} retry times: {}", retry_times);

      aimrt::rpc::Status status;
      for (int ii = 0; ii < retry_times; ++ii) {
        AIMRTE_DEBUG("{{service_name}}.{{rpc_func_name}} try for times #{}", ii);
        aimrt::rpc::Context ctx{ctx_ref};
        status = co_await proxy->{{service_name}}(ctx, req, rsp);
        if (status.OK()) co_return status;
      }
      AIMRTE_ERROR("RPC call {{service_name}} failed: {}", aimrt::rpc::Status::GetCodeMsg(status.Code()));
      co_return status;
    }
  );
}

std::vector<std::string> {{service_name}}Proxy::GetMethodNames(std::string service_name) {
  return {
    "ros2:/{{package_name}}/srv/{{service_name}}",
  };
}

}  // namespace res
}  // namespace srv
}  // namespace {{package_name}}
'''

    cc_file = str = t_cc_file \
        .replace("{{service_name}}", service_name) \
        .replace("{{package_name}}", package_name)
    return cc_file


if __name__ == '__main__':
    package_name = ""
    srv_file = ""
    output_path = ""
    for arg in sys.argv:
        kv = arg.split('=')
        if (kv[0] == '--pkg_name'):
            package_name = kv[1]
        elif (kv[0] == '--srv_file'):
            srv_file = kv[1]
        elif (kv[0] == '--output_path'):
            output_path = kv[1]

    (path, file) = os.path.split(srv_file)
    (filename, ext) = os.path.splitext(file)
    cc_file_path = os.path.join(output_path, filename + ".cc")
    h_file_path = os.path.join(output_path, filename + ".h")

    if not os.path.exists(output_path):
        os.makedirs(output_path)

    # cc file
    f_cc_file = open(cc_file_path, 'w')
    f_cc_file.write(gen_cc_file(package_name, filename))
    f_cc_file.close()
    print("create cc file: {} success".format(cc_file_path))

    # h file
    f_h_file = open(h_file_path, 'w')
    f_h_file.write(gen_h_file(package_name, filename))
    f_h_file.close()
    print("create h file: {} success".format(h_file_path))
