#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) 2025, AgiBot Inc.
# All rights reserved.

import sys

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf.compiler.plugin_pb2 import CodeGeneratorRequest as CodeGeneratorRequest
from google.protobuf.compiler.plugin_pb2 import CodeGeneratorResponse as CodeGeneratorResponse
from google.protobuf.descriptor_pb2 import FileDescriptorProto


class AimRTeCodeGenerator(object):
    t_one_get_type_support: str = r"""
  ::aimrt::GetProtobufMessageTypeSupport<::{{message_namespace}}::{{message_type}}>(),
"""

    t_one_include_file: str = r"""
#include "{{file_name}}.pb.h"
"""

    t_type_support_pkg_main: str = """/**
 * @brief This file was generated by protoc_plugin_gen_aimrt_cc_type_support.py,
 *        which is a self-defined pb compiler plugin, do not edit it!!!
 */

#include "src/interface/aimrt_type_support_pkg_c_interface/type_support_pkg_main.h"
#include "src/interface/aimrt_module_protobuf_interface/util/protobuf_type_support.h"

{{include_files}}

static const aimrt_type_support_base_t* type_support_array[]{
  {{get_type_supports}}
};

extern "C"
{
size_t AimRTDynlibGetTypeSupportArrayLength()
{
  return sizeof(type_support_array) / sizeof(type_support_array[0]);
}

const aimrt_type_support_base_t** AimRTDynlibGetTypeSupportArray()
{
  return type_support_array;
}
}
"""

    @staticmethod
    def gen_name_space_str(ns: str) -> str:
        return ns.replace(".", "::")

    def generate(self, request: CodeGeneratorRequest) -> CodeGeneratorResponse:
        """
        Generate code for the given request
        """

        # 所有受处理的 proto 文件的所有 message type supports，生成到一个 cc 中
        get_type_supports: str = ""
        include_files: str = ""

        for proto_file in request.proto_file:
            if proto_file.name not in request.file_to_generate:
                continue

            one_include_file: str = self.t_one_include_file \
                .replace("{{file_name}}", proto_file.name.replace('.proto', ''))
            include_files += one_include_file

            # Prepare those message types' namespace
            message_namespace: str = self.gen_name_space_str(proto_file.package)

            for message in proto_file.message_type:
                one_get_type_support: str = self.t_one_get_type_support        \
                    .replace("{{message_namespace}}", message_namespace) \
                    .replace("{{message_type}}", message.name)
                get_type_supports += one_get_type_support

        # 创建生成结果
        response: CodeGeneratorResponse = CodeGeneratorResponse()

        ccfile: CodeGeneratorResponse.File = CodeGeneratorResponse.File()
        ccfile.name = "type_support_pkg_main.cc"
        ccfile.content = self.t_type_support_pkg_main                  \
            .replace("{{get_type_supports}}", get_type_supports) \
            .replace("{{include_files}}", include_files)
        response.file.append(ccfile)

        response.supported_features |= CodeGeneratorResponse.FEATURE_PROTO3_OPTIONAL

        return response


if __name__ == '__main__':
    # Load the request from stdin
    request: CodeGeneratorRequest = CodeGeneratorRequest.FromString(sys.stdin.buffer.read())

    aimrte_code_generator: AimRTeCodeGenerator = AimRTeCodeGenerator()

    response: CodeGeneratorResponse = aimrte_code_generator.generate(request)

    # Serialize response and write to stdout
    sys.stdout.buffer.write(response.SerializeToString())
